---
layout: post
category: kernel
title: "中断"
date: 2024-02-03 15:00:00 +0800
---

<http://arthurchiao.art/blog/linux-irq-softirq-zh/>

## 软中断

中断的响应必须及时，在中断处理期间又必须要屏蔽掉其他的中断。那么对于中断处理函数比较耗时的场景怎么处理呢？

答案是分成两部分，确实需要在中断处理函数中处理的作为上半部分，下半部分（例如网卡的收发包）可以放在ksoftirqd内核线程中执行。ksoftirqd每个CPU核心存在一个，si占比表示当前软中断占用的CPU，如果过高会导致用户态的进程很卡。

ksoftirq, tasklet, workqueue的区别

|ksoftirq|tasklet|workqueue|
|-|-|-|
|依赖软中断子系统|依赖软中断子系统|不依赖软中断子系统|
|运行在软中断上下文|运行在软中断上下文|运行在进程上下文|
|open_softirq()注册，raise_softirq()唤醒|在运行时创建和初始化的softirq，softirq_init()初始化，tasklet_action()回调函数|create_worker()创建，wakeup_process()唤醒|
|只能运行在一个CPU上|只运行在一个CPU上|可以在CPU之间切换|
|静态编译，一般很少使用|可以在运行时创建和初始化|可以运行时创建和初始化|

如果处于软中断中申请自旋锁应该使用spin_lock_bh。

## 中断上下文

<https://www.cnblogs.com/wuchanming/p/4756756.html>

内核运行在中断上下文时，需要注意：

1. 不能睡眠或放弃CPU
2. 不要尝试获取信号量
3. 不要执行耗时的任务
4. 不要访问用户态的虚拟地址
5. 中断上下文不可抢占

总结：进入中断上下文后，进程无法被调度，内核必须快速处理退出中断上下文；而且注意屏蔽中断，避免当前中断的执行过程被其他中断打断。

因为中断上下文是不允许睡眠的，除了自旋锁以外的其他任何形式的锁都有可能导致睡眠或者进程切换，违背了中断的设计初衷，会发生不可预知的错误。所以，中断中一般使用自旋锁。

存疑：中断处理函数中，需要禁用中断，禁用内核抢占。因为如果此时一个高优先级的中断发生，并唤醒了一个进程进入睡眠状态，会导致CPU卡死。
