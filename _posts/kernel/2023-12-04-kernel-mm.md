---
layout: post
title: "linux 内存管理"
category: kernel
date: 2023-12-04 08:00 +0800
---

内核版本：4.19.289

## 1 LRU算法

参考来源：<https://www.ctyun.cn/zhishi/p-158284>

### 1.1 LRU链表

```c
enum lru_list {
	LRU_INACTIVE_ANON = LRU_BASE,
	LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,
	LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,
	LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,
	LRU_UNEVICTABLE,
	NR_LRU_LISTS
};
```

### 1.2 最简化版的LRU链表

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-simple.png)

新页面会被添加到活跃链表头，随着老化过程，会被移到不活跃链表头，再移动到链表尾，最后被移除，或者重新添加到活跃Lru链表。

加入lru：lru_cache_add。

### 1.3 二次机会法

核心思想： 在链表尾置换页面时，检查页面的访问位，访问位为0，就淘汰；访问位为1，就给它第二次机会同时将访问位清零;如果该页面被再次访问，访问位会置1，这样被频繁使用的页面，访问位总是1，就不会被淘汰。

linux使用PG_active和PG_referenced两个标志位来实现第二次机会法；

* PG_active：表示处于活跃链表；
* PG_referenced：软件记录访问标记(实际硬件访问标记从页表的PTE_YOUNG获取)

#### （1）LRU的原始状态

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-second-chance-1.png)

#### （2）新分配一个匿名页，PG_refereced为0

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-second-chance-2.png)

#### （3）访问匿名页

访问活跃链表的匿名页会将PG_referenced修改为1。

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-second-chance-3.png)

访问不活跃链表的匿名页也会将PG_referenced修改为1。

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-second-chance-4.png)

如果不活跃链表的匿名页PG_referenced已经为1，则修改为0，页面移到活跃链表。

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-second-chance-5.png)

#### （4）淘汰页面

注意，从尾部开始遍历不活跃链表，如果PG_referenced为1，则修改为0。如果已经为0,那么淘汰。

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-second-chance-6.png)

#### （5）页面老化：活跃链表迁移到不活跃链表

活跃链表尾部，如果PG_referenced为0，则迁移到不活跃链表。

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-second-chance-7.png)

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-second-chance-8.png)

#### 状态转换图

![img](https://github.com/Geass-LL/draw/raw/master/github-io/lru-second-chance-9.png)

## 2 rmap

<https://www.cnblogs.com/LoyenWang/p/12164683.html>

<https://richardweiyang-2.gitbook.io/kernel-exploring/00-index/01-anon_rmap_history>

简单总结：

一个物理页对应存在一个anon_vma，这里的anon_vma实际上是一个树结构，可以通过它查找到多个anon_vma。每个anon_vma可以通过avon_vma_chain再查找到对应的vma。

## memcg

## 内存分配

## 内存回收

参考：<https://segmentfault.com/a/1190000020937950>
