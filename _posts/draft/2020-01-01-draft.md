---
layout: post
date: 2020-01-01 16:00:00 +0800
title: "Some drafts"
category: draft
---

## systemd

#### Q：systemd的一些基础的服务是怎么拉起的？例如`systemd-tmpfiles-setup.service`。

A：通过`/lib/systemd/system/sysinit.target.wants/`目录创建的依赖关系。

## criu

criu能够用于进程的保存和恢复，基于的信息全部来自于内核接口，原声的criu没有内核态代码。

主函数的入口是`criu/crtools.c`，保存的主入口：`cr_dump_tasks`，恢复的主入口：`cr_restore_tasks`。

在保存进程状态前，criu会使用freezer cgroup或者ptrace冻结进程，避免状态不一致。保存一个进程涉及的关键信息很多，例如：信号、内存布局、cgroup等。

**内存恢复：** 调用`prctl(2)`的PR_SET_MM。
**PID的恢复：** 调用`clone(3)`配置PID。这里是如何确保PID不被复用的？

## epoll

epoll的底层机制使用的是`waitqueue`而不是软中断。

具体的文档实现可以参考：<https://www.jxhs.me/2021/04/08/linux%E5%86%85%E6%A0%B8Epoll-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/>

关键点总结：使用`epoll_create()`会创建一个eventpoll的对象，这个对象内包含epitem构成的红黑树。每个socket都会有一个waitqueue存放等待socket状态变更的进程（epitem）。当socket的状态发生变化时，epitem会被添加到就绪队列，然后epoll_wait()会唤醒等待的进程。

借epoll的专题写一下网卡接受到数据到进程处理的整个流程。

先看一下ChatGPT怎么说：

1. 数据包到达: 当网卡接收到一个数据包，它会根据预先配置的DMA（Direct Memory Access）将数据直接写入到内存中，并且触发一个硬件中断。
2. 硬件中断: CPU接收到硬件中断信号后，会暂停当前执行的任务，保存其状态，并执行中断服务程序（Interrupt Service Routine, ISR）。在Linux中，每个设备驱动会注册自己的ISR。
3. 中断服务程序: 网卡的ISR会进行一些基本的处理，如确认中断来源、读取状态寄存器、清除中断标志等，然后通常会将实际的数据处理工作推迟到一个软中断或工作队列中去完成，这样可以尽快释放中断处理程序，减少对CPU的占用。
4. NAPI（New API）: 现代Linux网络驱动通常使用NAPI结构来提高性能和减少中断负载。在高负载下，NAPI可以禁用中断，并改用轮询模式来处理网络数据包。
5. 软中断和工作队列: 数据包处理通常在软中断（softirq）或工作队列（workqueue）的上下文中进行。这些机制允许内核延迟处理函数的执行，从而不会阻塞中断服务程序。
6. 内核网络栈处理: 数据包被传递到内核网络栈，这里包括了多层处理，如链路层、网络层（IP层）、传输层（TCP/UDP）等。
7. 套接字缓冲区: 一旦内核确定了数据包属于哪个套接字，它会将数据包放入该套接字的接收缓冲区中。如果缓冲区已满，新的数据包可能会被丢弃，这取决于所使用的协议和套接字的设置。
8. 唤醒等待进程: 如果有用户态的进程正在等待这些数据（例如，通过调用read()或recv()等系统调用），内核会将这些进程从它们的等待队列中唤醒。
9. 系统调用: 用户态的应用程序通过系统调用与内核通信，请求网络数据。常见的系统调用包括read(), recv(), recvfrom(), recvmsg()等。
10. 用户态处理: 用户进程接收到数据后，可以进行相应的处理，如解析应用层协议，处理业务逻辑等。

## 故障页隔离



